theory Gatekeeper
begin

builtins: asymmetric-encryption, symmetric-encryption, hashing

// Define Message Authentication Code (MAC)
functions: mac/2, ver/3, true/0
equations: ver(k, m, mac(k, m)) = true

// Define the shared symmetric key
functions: shk/0 [private]

// Define the gateway role
functions: gw/0 [private] // !!!: mark this as private temporarily

// Public Key Infrastructure
section{* PKI *}

/*
  Generates a long-term key for a party
 */
rule Register_pk:
    [ Fr(~ltkA) ] // Fr(x) generates a fresh (random) value
                  // `~ltkA` stands for a long-term key or a private key
  --[ GenLtk($A, ~ltkA) ]->
    [ !Ltk($A, ~ltkA) // Binds the long-term key to the party `$A`
    , !Pk($A, pk(~ltkA)) // Models the distribution of the public key
    ]

/*
  Gets the public key from the PKI
 */
rule Get_pk:
    [ !Pk(A, pubkey) ]
  --[ GetPk(A, pubkey) ]->
    [ Out(pubkey) ] // Outputs the public key so others and attackers have knowledge

section{* Attacker *}

/*
  The adversarial capability to reveal long-term keys of parties
 */
rule Reveal_ltk:
    [ !Ltk(A, ltk) ]
  --[ RevealLtk(A) ]->
    [ Out(ltk) ]

/*
  The adversarial capability to reveal the shared key
 */
rule Reveal_shk:
    []
  --[ RevealShk() ]->
    [ Out(shk) ]

section{* Channels *}

rule ChanOut_A_P:
    [ Out_P($A, x) ]
  --[ ChanOut_A_P($A, x) ]->
    [ Out_SG($A, gw, x) ]

rule ChanOut_A_SG:
    [ Out_SG($A, gw, x) ]
  --[ ChanOut_A_SG($A, gw, x) ]->
    [ Out(<$A, gw, x>) ]

rule ChanIn_A_SG:
    [ In(<$A, gw, x>) ]
  --[ ChanIn_A_SG($A, gw, x) ]->
    [ In_SG($A, gw, x) ]

rule ChanOut_A_GR:
    [ Out_GR($A, gw, x) ]
  --[ ChanOut_A_GR($A, gw, $B, x)
    , Neq($A, $B)
    , Neq(gw, $B) ]->
    [ Out(<$A, gw, $B, x>) ]

rule ChanIn_A_GR:
    [ In(<$A, gw, $B, x>) ]
  --[ ChanIn_A_GR($A, gw, $B, x) ]->
    [ In_GR($A, gw, $B, x) ]

rule ChanIn_A_P:
    [ In_GR($A, gw, $B, x) ]
  --[ ChanIn_A_P($A, x) ]->
    [ In_P($A, x) ]

section{* Broadcast Communication *}

rule SendPDU:
    [ Fr(~data) ]
  --[ Send($A, ~data) ]->
    [ Out_P($A, <~data, mac(shk, ~data)>) ]

rule ReceivePDU:
    [ In_P($A, <data, mactag>) ]
  --[ Neq($A, $B)
    , Eq(ver(shk, data, mactag), true)
    , Receive($B, data)
    ]->
    []

rule Gateway:
    [ In_SG($A, gw, data) ]
  --[]->
    [ Out_GR($A, gw, data) ]

// Restrictions
restriction Equality:
    "All x y #i. Eq(x, y) @ #i ==> x = y"

restriction Inequality:
    "All x #i. Neq(x, x) @ #i ==> F"

section{* Security Properties *}

// Executability
lemma Executable:
    exists-trace
    " Ex A B data #i #j.
        Send(A, data) @ #i
      & Receive(B, data) @ #j
      & i < j
    "

// Source authentication
// lemma SourceAuthentication:
//     " All sender1 sender2 receiver data #i #j.
//         Send(sender1, data) @ #i
//       & Send(sender2, data) @ #i
//       & Receive(receiver, data) @ #j
//         ==> sender1 = sender2
//     "

lemma InjectiveGroupAgreement:
    " All receiver data #i.
        Receive(receiver, data) @ #i
        ==>	(
              Ex sender #j. Send(sender, data) @ #j
            & #j < #i
            & not (
                    Ex sender2 #j2. Send(sender2, data) @ #j2
                  & #j2 < #i
                  )
            )
    "

lemma NonInjectiveGroupAgreement[reuse]:
    " All receiver data #i.
        Receive(receiver, data) @i
        ==> (
              Ex sender #j. Send(sender, data) @ j)
            | ( Ex #r. RevealShk() @ r )
    "

end
